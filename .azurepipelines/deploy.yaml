# Azure DevOps CD Pipeline for Azure DevOps MCP Server
# Deploy to Azure Container Apps
# This pipeline is triggered manually, by updates to the deployment pipeline or by completion of the build pipeline

trigger:
  branches:
    include:
      - main
  paths:
    include:
      - .azurepipelines/deploy.yaml

resources:
  pipelines:
  - pipeline: ci
    source: 'ado-mcp-ci'
    trigger:
      branches:
        include:
        - main

variables:
  # Azure service connection for deployment
  azureServiceConnection: 'Hire Ground Enterprise'  # Replace with your Azure service connection

  # Environment configuration - Update these values based on your deployment
  environmentName: 'Production'  # Replace with your environment name
  subscriptionId: '80188524-4199-4293-8e33-7ba33daa0f2a'  # Replace with your Azure subscription ID
  location: 'eastus2'  # Replace with your deployment region
  azureDevOpsOrgName: 'hireground'  # Replace with your Azure DevOps organization name

  # Agent configuration
  vmImageName: 'ubuntu-latest'

stages:
- stage: Deploy
  displayName: Deploy to Azure Container Apps
  variables:
    resourceGroupName: 'rg-devops'
    containerAppName: 'ado-mcp-server-eus2'
  jobs:
  - deployment: DeployToContainerApps
    displayName: Deploy to Azure Container Apps
    pool:
      vmImage: $(vmImageName)
    environment: 'Hire Ground DevOps'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: none

          - task: DownloadPipelineArtifact@2
            displayName: Download deployment metadata
            inputs:
              buildType: 'specific'
              project: '$(System.TeamProjectId)'
              definition: '$(resources.pipeline.ci.pipelineId)'
              buildVersionToDownload: 'latest'
              artifactName: 'deployment-metadata'
              targetPath: '$(Pipeline.Workspace)/metadata'

          - task: DownloadPipelineArtifact@2
            displayName: Download infrastructure files
            inputs:
              buildType: 'specific'
              project: '$(System.TeamProjectId)'
              definition: '$(resources.pipeline.ci.pipelineId)'
              buildVersionToDownload: 'latest'
              artifactName: 'infra'
              targetPath: '$(Pipeline.Workspace)/infra'

          - task: PowerShell@2
            displayName: Load deployment metadata
            inputs:
              targetType: 'inline'
              script: |
                $metadata = Get-Content "$(Pipeline.Workspace)/metadata/deployment-metadata.json" | ConvertFrom-Json

                Write-Host "##[section]Deployment Metadata:"
                Write-Host "Build ID: $($metadata.buildId)"
                Write-Host "Source Version: $($metadata.sourceVersion)"
                Write-Host "Image Tag: $($metadata.imageTag)"
                Write-Host "Container Registry: $($metadata.containerRegistry)"
                Write-Host "Image Repository: $($metadata.imageRepository)"
                Write-Host "Build Timestamp: $($metadata.timestamp)"

                # Set variables for use in subsequent tasks
                Write-Host "##vso[task.setvariable variable=newImageTag]$($metadata.containerRegistry)/$($metadata.imageRepository):$($metadata.imageTag)"
                Write-Host "##vso[task.setvariable variable=buildId]$($metadata.buildId)"

          - task: AzureCLI@2
            displayName: Deploy infrastructure using Bicep
            inputs:
              azureSubscription: '$(azureServiceConnection)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                set -e

                echo "##[section]Deploying infrastructure using Bicep templates"

                echo "Resource Group: $(resourceGroupName)"
                echo "Location: $(location)"
                echo "Environment: $(environmentName)"                # Create resource group if it doesn't exist
                echo "##[command]Ensuring resource group exists..."
                az group create \
                  --name $(resourceGroupName) \
                  --location $(location) \
                  --tags environment=$(environmentName) project="azure-devops-mcp"                # Deploy main Bicep template
                echo "##[command]Deploying Bicep infrastructure..."

                # Check if the Bicep file exists
                if [ ! -f "$(Pipeline.Workspace)/infra/main.bicep" ]; then
                  echo "##[error]Bicep file not found at $(Pipeline.Workspace)/infra/main.bicep"
                  echo "Available files in infra directory:"
                  ls -la "$(Pipeline.Workspace)/infra/" || echo "Infra directory not found"
                  exit 1
                fi

                # Execute the deployment with better error handling
                echo "##[command]Executing Bicep deployment..."
                DEPLOYMENT_OUTPUT=$(az deployment sub create \
                  --location $(location) \
                  --template-file "$(Pipeline.Workspace)/infra/main.bicep" \
                  --parameters \
                    environmentName="$(environmentName)" \
                    location="$(location)" \
                    azureDevOpsOrgName="$(azureDevOpsOrgName)" \
                  --output json 2>&1)

                DEPLOYMENT_EXIT_CODE=$?

                if [ $DEPLOYMENT_EXIT_CODE -ne 0 ]; then
                  echo "##[error]Bicep deployment failed with exit code: $DEPLOYMENT_EXIT_CODE"
                  echo "##[error]Deployment output: $DEPLOYMENT_OUTPUT"
                  exit $DEPLOYMENT_EXIT_CODE
                fi

                echo "##[section]Infrastructure deployment completed successfully!"

                # Extract key outputs for later use
                APP_URL=$(echo $DEPLOYMENT_OUTPUT | jq -r '.properties.outputs.SERVICE_WEB_ENDPOINT_URL.value // empty')

                if [ -n "$APP_URL" ]; then
                  echo "##vso[task.setvariable variable=deployedAppUrl]$APP_URL"
                  echo "Application URL: $APP_URL"
                else
                  echo "##[warning]Could not extract application URL from deployment output"
                fi

                # Also extract other useful outputs
                REGISTRY_ENDPOINT=$(echo $DEPLOYMENT_OUTPUT | jq -r '.properties.outputs.AZURE_CONTAINER_REGISTRY_ENDPOINT.value // empty')
                KEY_VAULT_ENDPOINT=$(echo $DEPLOYMENT_OUTPUT | jq -r '.properties.outputs.AZURE_KEY_VAULT_ENDPOINT.value // empty')

                echo "Registry Endpoint: $REGISTRY_ENDPOINT"
                echo "Key Vault Endpoint: $KEY_VAULT_ENDPOINT"

          - task: AzureCLI@2
            displayName: Deploy container to Azure Container Apps
            inputs:
              azureSubscription: '$(azureServiceConnection)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                set -e

                echo "##[section]Starting deployment to Azure Container Apps"
                echo "Resource Group: $(resourceGroupName)"
                echo "Container App: $(containerAppName)"
                echo "New Image: $(newImageTag)"

                # Check if container app exists
                if az containerapp show --name $(containerAppName) --resource-group $(resourceGroupName) --output none 2>/dev/null; then
                  echo "##[command]Container App exists, updating with new image..."

                  # Update existing container app
                  az containerapp update \
                    --name $(containerAppName) \
                    --resource-group $(resourceGroupName) \
                    --image $(newImageTag) \
                    --output table

                  echo "##[section]Container App updated successfully!"
                else
                  echo "##[warning]Container App $(containerAppName) not found in resource group $(resourceGroupName)"
                  echo "Please ensure the infrastructure is deployed first using 'azd up' or Bicep templates"
                  exit 1
                fi

                # Wait for deployment to complete
                echo "##[command]Waiting for deployment to complete..."
                sleep 30

                # Get the application URL
                FQDN=$(az containerapp show \
                  --name $(containerAppName) \
                  --resource-group $(resourceGroupName) \
                  --query "properties.configuration.ingress.fqdn" \
                  --output tsv)

                if [ -n "$FQDN" ]; then
                  echo "##[section]âœ… Deployment completed successfully!"
                  echo "##[command]ðŸš€ Application URL: https://$FQDN"
                  echo "##vso[task.setvariable variable=APP_URL;isOutput=true]https://$FQDN"
                else
                  echo "##[error]Failed to retrieve application URL"
                  exit 1
                fi

          - task: AzureCLI@2
            displayName: Verify deployment health
            inputs:
              azureSubscription: '$(azureServiceConnection)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "##[section]Verifying deployment health..."

                # Get container app status
                STATUS=$(az containerapp show \
                  --name $(containerAppName) \
                  --resource-group $(resourceGroupName) \
                  --query "properties.provisioningState" \
                  --output tsv)

                echo "Container App provisioning state: $STATUS"

                if [ "$STATUS" = "Succeeded" ]; then
                  echo "##[section]âœ… Container App is healthy and running!"

                  # Get replica status
                  REPLICAS=$(az containerapp replica list \
                    --name $(containerAppName) \
                    --resource-group $(resourceGroupName) \
                    --query "length(@)" \
                    --output tsv)

                  echo "Active replicas: $REPLICAS"
                else
                  echo "##[warning]Container App status: $STATUS"
                  echo "Check the Azure portal for more details"
                fi

- stage: PostDeployment
  displayName: Post-deployment tasks
  dependsOn: Deploy
  condition: succeeded()
  jobs:
  - job: NotifySuccess
    displayName: Deployment notification
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: DownloadPipelineArtifact@2
      displayName: Download deployment metadata
      inputs:
        buildType: 'specific'
        project: '$(System.TeamProjectId)'
        definition: '$(resources.pipeline.ci.pipelineId)'
        buildVersionToDownload: 'latest'
        artifactName: 'deployment-metadata'
        targetPath: '$(Pipeline.Workspace)/metadata'

    - task: PowerShell@2
      displayName: Send deployment notification
      inputs:
        targetType: 'inline'
        script: |
          $metadata = Get-Content "$(Pipeline.Workspace)/metadata/deployment-metadata.json" | ConvertFrom-Json

          Write-Host "##[section]ðŸŽ‰ Azure DevOps MCP Server Deployment Summary"
          Write-Host "##[command]Environment: $(environmentName)"
          Write-Host "##[command]Build ID: $($metadata.buildId)"
          Write-Host "##[command]Image Tag: $($metadata.imageTag)"
          Write-Host "##[command]Container Registry: $($metadata.containerRegistry)"
          Write-Host "##[command]Resource Group: $(resourceGroupName)"
          Write-Host "##[command]Source Version: $($metadata.sourceVersion)"
          Write-Host "##[command]Build Timestamp: $($metadata.timestamp)"
          Write-Host ""
          Write-Host "##[section]âœ… Deployment completed successfully!"
          Write-Host "##[command]The Azure DevOps MCP Server is now running in Azure Container Apps"
